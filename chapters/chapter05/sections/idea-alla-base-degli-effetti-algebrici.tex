\section{Idea alla base degli effetti algebrici}
Nella teoria elaborata da Plotkin e Power, un effetto viene modellato tramite un insieme di operazioni e una serie di equazioni che ne descrivono le proprietà~\cite{cit:handling-algebraic-effects,cit:computational-effects-and-operations-an-overview}.

Le operazioni di un effetto determinano le modalità con cui questo può verificarsi; possono quindi essere considerate come dei \emph{costruttori} di un effetto~\cite{cit:algebraic-operations-and-generic-effects}.
Per poter interpretare un effetto e assegnarvi semantica vengono invece utilizzati degli appositi \emph{handler}, o distruttori. Questi specificano come l'esecuzione del programma deve proseguire al verificarsi di ciascuna operazione di uno specifico effetto.

Prima di poter proseguire nella trattazione degli effetti è necessario dare una breve introduzione a Koka: il linguaggio di riferimento utilizzato per tutti gli esempi riportati.

\subsection{Il linguaggio Koka}
Koka è un linguaggio di ricerca con supporto agli effetti algebrici; alcune delle sue caratteristiche chiave sono:
\begin{itemize}
  \item Tipizzazione statica e \emph{type inference}
  \item Supporto agli effetti algebrici e \emph{effect inference} per minimizzare la necessità di annotazioni
  \item Un cuore funzionale composto da pochi costrutti quanto più generali e componibili possibile: funzioni di prima classe, tipi di dato algebrici, effetti algebrici e handler
  \item Uso del metodo Perceus~\cite{cit:perceus-garbage-free-reference-counting-with-reuse} per gestire automaticamente la memoria tramite \emph{reference counting}. Questa tecnica elimina il bisogno di avere un \emph{garbage collector} o un \emph{runtime system} ottenendo ottime prestazioni. Inoltre, l'uso di Perceus rende possibile programmare secondo uno stile che i suoi autori definiscono \emph{Functional But In Place}: grazie all'analisi del \emph{reference counter} è possibile ottimizzare algoritmi puramente funzionali -- che utilizzano strutture dati immutabili -- in modo tale da eseguire mutazioni \emph{in place} in maniera trasparente al programmatore~\cite{cit:koka-benchmarks}
\end{itemize}

\subsubsection{Sintassi di base}
Per dichiarare una funzione viene utilizzata la parola chiave \lstinline{fun}, mentre per dichiarare una funzione anonima la parola chiave da utilizzare è \lstinline{fn}:
\begin{lstlisting}[language=koka]
fun main() {
  repeat(10, fn() {
    println("Hello, Koka!")
  })
}
\end{lstlisting}
Nell'esempio viene chiamata la funzione \lstinline{repeat} con due argomenti: una funzione anonima che descrive l'azione da compiere e un numero che indica quante volte ripetere l'azione.

Inoltre, è possibile rimuovere le parentesi graffe in quanto ogni blocco di codice indentato viene implicitamente considerato come compreso fra parentesi graffe:
\begin{lstlisting}[language=koka]
fun main()
  repeat(10, fn()
    println("Hello, Koka!")
  )
\end{lstlisting}

In Koka -- così come in Swift e Kotlin -- è disponibile zucchero sintattico per semplificare la scrittura delle \emph{trailing lambda}: qualora l'ultimo argomento di una funzione sia una funzione anonima, questa può seguire direttamente la chiamata a funzione. L'esempio precedente può quindi essere riscritto come:
\begin{lstlisting}[language=koka]
fun main()
  repeat(10) fn()
    println("Hello, Koka!")
\end{lstlisting}
Infine, se la funzione anonima non presenta argomenti allora si può omettere \lstinline{fn()}:
\begin{lstlisting}[language=koka]
fun main()
  repeat(10)
    println("Hello, Koka!")
\end{lstlisting}

Un'altra regola sintattica che verrà utilizzata frequentemente negli esempi a seguire è l'uso della parola chiave \lstinline{with}. Questa permette di eliminare l'annidamento di funzioni che prendono in input delle funzioni anonime:
\begin{lstlisting}
with x <- f(a1,...,an)
<body>
\end{lstlisting}
Viene trasformata in \lstinline|f(a1,...,an, fn(x){ <body> })|. Inoltre, se la funzione anonima non prende argomenti, è possibile omettere \lstinline{x <-}.

Perciò, l'esempio precedente può essere riscritto come:
\begin{lstlisting}[language=koka]
fun main()
  with repeat(10)
  println("Hello, Koka!")
\end{lstlisting}

Infine, in maniera analoga a Go, in Koka è possibile usare la sintassi generalmente associata alla chiamata di un metodo per poter invocare una funzione: \lstinline{a1.f(a2,...,an)} non è altro che zucchero sintattico per \lstinline{f(a1,a2,...,an)}.
Si osservi per esempio la seguente porzione di codice:
\begin{lstlisting}[language=koka]
fun main() {
  for(1, 10, fn(i) {
    println(show(i))
  })
}
\end{lstlisting}
In Koka, diverse strutture di controllo come \lstinline{for} e \lstinline{while} sono semplici funzioni definite nella libreria standard. In questo caso \lstinline{for} prende in input due indici di inizio e fine e una funzione anonima che indica l'azione che dev'essere ripetuta.
Utilizzando lo zucchero sintattico descritto in precedenza il codice può essere trasformato in:
\begin{lstlisting}[language=koka]
fun main()
  with i <- for(1, 10)
  println(i.show)
\end{lstlisting}

\subsubsection{Tipi di dato algebrici e pattern matching}
Koka permette di definire tipi di dato algebrici tramite la parola chiave \lstinline{type} e separando i diversi costruttori su linee differenti:
\begin{lstlisting}[language=koka]
type color
  Red
  Green
  Blue
\end{lstlisting}
Inoltre, in maniera analoga alle enumerazioni in Scala, un tipo può essere generico e ciascun costruttore può avere campi differenti:
\begin{lstlisting}[language=koka]
type optional<a>
  Some(value: a)
  Empty
\end{lstlisting}
È possibile accedere ai campi di uno specifico costruttore tramite pattern matching sui valori di un certo tipo:
\begin{lstlisting}[language=koka]
fun map(option, f)
  match option
    Some(value) -> Some(f(value))
    Empty       -> Empty

fun main()
  val option = Some(1)
  option.map(fn(i) { i + 2 }) // Some(3)
\end{lstlisting}
Si noti come non è stato necessario annotare il tipo dei parametri della funzione \lstinline{map}, nè il suo tipo di ritorno: il tipo della funzione viene correttamente inferito come \lstinline{forall<a,b> (option : optional<a>, f : (a) -> b) -> optional<b>}.

\subsubsection{Effect system}
In Koka è presente un effect system che permette di tracciare i side effect di ciascuna funzione. Il compito di tale effect system è dare la garanzia, a tempo di compilazione, della corretta gestione dei side effect; in particolare, un programma che compili senza errori non potrà presentare side effect che non siano stati gestiti esplicitamente~\cite{cit:koka-programming-with-row-polymorphic-effect-types}.

In Koka una funzione ha un tipo della forma \lstinline{a -> e b} per indicare che prende in input un valore di tipo \lstinline{a} e produce un valore di tipo \lstinline{b} producendo un side effect \lstinline{e}. Perciò un side effect può avere luogo solo come risultato della chiamata di una funzione; un valore di un qualunque altro tipo non può avere side effect~\cite{cit:algebraic-effects-for-functional-programming}.

Il tipo della funzione \lstinline{map} mostrata in precedenza è in realtà incompleto poiché sono state omesse le annotazioni relative agli effetti. In realtà il tipo più generale possibile inferito dal compilatore è:
\begin{lstlisting}[language=koka]
forall<a,b,e>
(option : optional<a>, f : (a) -> e b) -> e optional<b>
\end{lstlisting}
Il primo valore preso in input ha tipo \lstinline{optional<a>} mentre la funzione \lstinline{f} presa in input può trasformare un valore \lstinline{a} in un valore \lstinline{b} producendo un generico effetto \lstinline{e}.
Complessivamente, la funzione \lstinline{map} restituisce un valore \lstinline{optional<b>} producendo un effetto \lstinline{e}.

Osservando il corpo della funzione è possibile osservare come questa non produca alcun side effect limitandosi a effettuare pattern matching sul valore opzionale.
L'unica azione ``pericolosa'' consiste nella chiamata della funzione \lstinline{f}: questa infatti potrebbe presentare dei side effect arbitrari (rappresentati dal generico \lstinline{e} nel tipo inferito). Poiché \lstinline{map} chiama nel proprio corpo la funzione \lstinline{f} allora dovrà avere espresso nella propria \emph{type signature} il fatto che può produrre gli effetti di \lstinline{f}.

In generale, se una funzione chiama nel proprio corpo una serie di funzioni con side effect dovrà riportarli tutti nel proprio tipo:
\begin{lstlisting}[language=koka]
fun function() // () -> <e1,...,en> ()
  func1(a1,...) // (a1, ...) -> e1 r1
  ... 
  funcn(an,...) // (an, ...) -> en rn 
  ()
\end{lstlisting}
La notazione \lstinline{<e1,...,en>} indica la lista di tutti i possibili side effect della funzione. Come è possibile osservare, l'effect system permette di tracciare tutti i side effect che non possono essere ``nascosti'' all'interno del corpo di una funzione.

Il tipo di una funzione senza alcun side effect può essere indicato come \lstinline{a -> <> b} o, più semplicemente, \lstinline{a -> b}.
Si consideri per esempio la seguente funzione:
\begin{lstlisting}[language=koka]
fun sum(x, y)
  x + y
\end{lstlisting}
Il tipo inferito è \lstinline{(x : int, y : int) -> <> int}; quindi, semplicemente osservandone il tipo, è possibile capire che la funzione è pura e non presenta alcun side effect.

Se l'implementazione di \lstinline{sum} dovesse cambiare, per esempio chiamando una funzione con side effect al proprio interno, allora questo comportamento verrebbe rispecchiato nel tipo:
\begin{lstlisting}[language=koka]
fun sum(x, y)
  println("Side effect!")
  x + y
\end{lstlisting}
In questo caso il nuovo tipo inferito è \lstinline{(x : int, y : int) -> console int} rendendo evidente come la funzione in questo caso presenti il side effect di interagire con la console.


\section{Definizione di un effetto}
\mustfix{Spostare qui l'introduzione all'inizio del capitolo? Rivedere l'ordine dell'esposizione}

\subsection{Effetto del fallimento}
Come descritto all'inizio del capitolo un effetto si compone di una serie di costruttori che sono le azioni che possono generarlo.
Per esempio l'effetto del fallimento di una computazione può essere definito come:
\begin{lstlisting}[language=koka]
effect failure
  ctl fail(): a
\end{lstlisting}

In Koka la parola chiave \lstinline{effect} definisce un effetto e i suoi costruttori sono definiti tramite la parola chiave \lstinline{ctl}.
In questo caso, l'effetto del fallimento è definito da una sola operazione \lstinline{fail} che produce una funzione omonima di tipo \lstinline{forall<a> () -> failure a}.

Una funzione che fa uso del costruttore \lstinline{fail} avrà automaticamente fra i propri effetti quello del fallimento:
\begin{lstlisting}[language=koka]
fun div(n, m)
  match m
    0 -> fail()
    _ -> n / m
\end{lstlisting}
Il tipo inferito per \lstinline{safe-div} sarà \lstinline{(n : int, m : int) -> failure int}. Semplicemente osservando il tipo della funzione è possibile capire che questa potrebbe fallire, l'effect system fa in modo che non sia possibile ignorare questo aspetto.

\subsection{Modellazione di uno stato mutabile}
Seguendo la stessa strategia evidenziata per l'effetto del fallimento è possibile definire l'effetto che permette di modellare la presenza di uno stato mutabile:
\begin{lstlisting}[language=koka]
effect state<s>
  ctl get(): s
  ctl set(new-state: s): ()
\end{lstlisting}
In questo caso l'effetto è parametrico rispetto a un generico stato di tipo \lstinline{s}; l'operazione di \lstinline{get} non prende alcun parametro e restituisce un valore di tipo \lstinline{s}, l'operazione \lstinline{set} prende in input il nuovo stato e non restituisce alcun valore.

È possibile combinare queste operazioni di base per realizzare funzioni più complesse, per esempio:
\begin{lstlisting}[language=koka]
fun update(f)
  val current-state = get()
  val new-state = f(current-state)
  set(new-state)
\end{lstlisting}
In questo caso la funzione prende in input una funzione \lstinline{f} che viene utilizzata per trasformare lo stato e aggiornarlo.

Poiché \lstinline{update} utilizza al proprio interno le operazioni \lstinline{get} e \lstinline{set} avrà nel proprio tipo l'effetto dello stato: il tipo inferito è \lstinline{(f : (s) -> e s) -> <state<s>|e> ()}.
Si noti come il tipo di \lstinline{f} è stato inferito come il più generico possibile: vale a dire che questa funzione potrebbe avere un qualunque side effect \lstinline{e}.
Per questo motivo il tipo di \lstinline{update} combina sia l'effetto dello stato che i possibili ulteriori effetti provenienti dall'uso del proprio argomento.

\mustfix{Bisognerebbe parlare dei row type nell'effect system}

\mustfix{bisogna dire che una funzione con tipo a -> e b può essere usata come una normale funzione a -> b e cambia che l'effetto viene propagato alla funzione dentro la quale si trova!!!}

\section{Interpretazione degli effetti}
Fino a questo momento gli effetti sono stati descritti in maniera astratta definendo una serie di operazioni; queste definiscono un'interfaccia attraverso la quale è possibile generare l'effetto desiderato.

Per poter dare una semantica alle operazioni di un effetto è necessario definire un \emph{handler}. Gli handler sono anche detti distruttori in quanto rappresentano un meccanismo duale rispetto alle operazioni: mentre quest'ultime arricchiscono il tipo di una funzione aggiungendovi effetti, gli handler permettono di scaricare gli effetti dal tipo di una funzione.

In generale, un handler per l'effetto \lstinline{e1} sarà una funzione con tipo \lstinline{(a -> <e1|e> b) -> (a' -> e b')}: vale a dire che l'handler può prendere in input una computazione che può mettere in atto l'effetto gestito e restituisce una nuova computazione che non presenta più l'effetto fra quelli che può avere.

\subsection{Gestione del fallimento di una computazione}
Per poter definire un handler in Koka viene utilizzata la parola chiave \lstinline{handle} a cui viene passata come argomento la computazione della quale devono essere gestiti gli effetti.

Considerando il side effect del fallimento di una computazione è possibile definire un handler che, in caso venga chiamata l'operazione \lstinline{fail}, restituisca un valore di default:
\begin{lstlisting}[language=koka]
fun catch-default(default, computation)
  handle(computation)
    ctl fail() -> default
\end{lstlisting}

\section{Koka}
\section{Definizione degli effetti}
\subsection{L'effetto del fallimento}
\subsection{L'effetto dello stato}
\section{interpretazione degli effetti}
\section{Composizione di effetti}


% Spiegare cosa succede quando viene chiamata un'operazione: è come se si verificasse un'eccezione e il controllo viene passato a uno dei rami dell'handler a seconda dell'operazione che è stata chiamata (esempio Catch)
% È anche possibile intercettare il caso in cui la computazione termini senza mai chiamare un'operazione (esempio Maybe, mostrare come sia facile passare da una rappresentazione all'altra (try/untry))
% Prima osservazione: è possibile definire strutture di controllo di flusso come blocchi try/catch/finally in user space! (provare a implementare finally)

% Passare all'esempio dello stato mutabile
% Mostrare l'uso di `resume`: quindi gli effetti non sono semplici eccezioni, possono essere visti -- dal punto di vista operazionale -- come delle eccezioni recuperabili! È possibile, chiamando resume, ripristinare il normale flusso di controllo nel punto esatto in cui l'operazione è stata invocata.
% Per poter far riprendere il flusso, resume deve essere chiamata con un valore che abbia il tipo di ritorno atteso dall'operazione in quanto è il contratto che questa stabilisce.
% Nel caso di get quindi ``resume' è una funzione che prende in input un valore del tipo dello stato
% Nel caso di set invece resume non prende alcun valore in input e può sempre essere fatta ripartire. Tuttavia, l'operazione fornisce il nuovo stato che può essere aggiornato

% Parentesi sulle variabili in Koka: in Koka è possibile avere variabili e il loro utilizzo viene riflesso negli effetti delle computazioni che le presentano! Inoltre, Koka permette di eliminare tale side effect dalla firma della funzione se questo non è osservabile esternamente. Quindi è possibile utilizzare in maniera opportunistica la mutazione di variabili e se non è osservabile esternamente non viene considerata come un side effect in quanto non è visibile dall'esterno e non altera la natura matematica della funzione.

% State primo esempio del potere espressivo degli effetti, la computazione può essere ripresa nel punto in cui è stata interrotta.

% Altri effetti iteratori (evidenziare come questi necessitino di supporto diretto del compilatore, in questo caso sono generalizzati dagli effetti!) (pipe di generatore/consumatore)

% Effetti più complessi: NON DETERMINISMO
% Interessante esempio che permette di capire come ``resume'' non sia altro che una normale funzione, le funzioni sono elementi di prima classe e possono essere passate come argomento, invocate più volte, etc.
% in questo caso l'interpretazioni possono essere molteplici! Si sceglie sempre una delle due opzioni, scelta non deterministica (mostrare come un handler può quindi rimuovere un effetto ma aggiungerne altri!!!!), oppure si esplorano tutti i rami della computazione uno dopo l'altro

% Composizione di più effetti
% È automatica! L'effect system traccia e accumula tutti gli effetti, parlare di effect polymorphism e row type nell'effect system, mostrare una computazione che usa più effetti
% Gestione di più effetti, basta applicare tutti gli handler necessari, anche in questo caso è automatico! 
% Anche in questo caso potrebbe cambiare la semantica dell'operazione in base all'ordine con cui sono applicati gli handler (esempio di fallimento e stato mutabile)

% Confronto con l'approccio monadico
% Boilerplate nullo: gli effetti sono elementi di prima classe che non devono essere codificati tramite meccanismi come le type class.
% È difficile comporre le monadi (vedi gli stack) mentre gli effetti vengono composti e propagati automaticamente
% Definire una monade richiede concentrarsi su come le operazioni vengono concatenate (flatMap), ed è questo che da semantica. Nel caso degli effetti, invece, si da semantica definendo degli handler e l'attenzione è sulle operazioni! (In questo, l'approccio degli effetti è più simile alle free monad dove in quel caso l'istanza di monade si otteneva in automatico e l'interpretazione avveniva stabilendo come comportarsi ad ogni operazione)
% È possibile scrivere il codice in maniera diretta, senza dover ricorrere alla for comprehension e bind monadico.
% Il carico cognitivo per il programmatore è estremamente ridotto
% Facendo un confronto specifico con scala, inoltre un vantaggio significativo è la possibilità di avere inferenza completa di effetti! Con gli approcci MTL/Free monad è sempre necessario indicare esplicitamente gli effetti delle computazioni nel tipo delle funzioni. In questo caso il programmatore ha a disposizione un meccanismo di innferenza potente e può farsi guidare da questo se volesse inserire esplicitamente le annotazioni (anche se non sono obbligatorie!)

% Codice estremamente conciso

% Koka utilizzato per Makoko

% Possibile accenno alle tecniche implementative?

% Potenza del meccanismo: molto conveniente per il compilatore una sola cosa che va supportata e ottimizzata e sottende a tutti i meccanismi di controllo di flusso: iteratori, async-await, ... che quindi possono essere semplicemente implementati come librerie basandosi sugli effetti

